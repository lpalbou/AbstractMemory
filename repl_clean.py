#!/usr/bin/env python3
"""
AbstractMemory REPL - Clean AbstractCore Integration

This is a clean REPL implementation that properly uses AbstractCore's BasicSession
with memory automation. No ReAct loops, no manual tool execution - just clean
memory-enhanced conversation.

Usage:
    python repl_clean.py
    python repl_clean.py --memory-path my_memory --user-id alice
    python repl_clean.py --provider lmstudio --model qwen/qwen3-coder-30b
"""

import argparse
import sys
import time
from pathlib import Path

# AbstractCore imports
try:
    from abstractllm import create_llm
    from abstractllm.embeddings import EmbeddingManager
except ImportError as e:
    print(f"‚ö†Ô∏è  AbstractCore not found: {e}")
    print("Please install: pip install abstractcore[embeddings]")
    sys.exit(1)

# AbstractMemory imports
from abstractmemory.memory_session import MemorySession


class AbstractMemoryREPL:
    """Clean REPL for AbstractMemory using proper AbstractCore integration."""

    def __init__(self, provider_name: str, model: str, memory_path: str = "repl_memory",
                 user_id: str = "user", location: str = "terminal", verbose: bool = False):
        """Initialize the REPL with memory-enhanced session."""
        
        self.provider_name = provider_name
        self.model_name = model
        self.memory_path = Path(memory_path)
        self.user_id = user_id
        self.location = location
        self.verbose = verbose
        
        # Initialize provider
        print(f"üß† Initializing AbstractMemory...")
        print(f"   Memory Path: {memory_path}")
        print(f"   User ID: {user_id}")
        print(f"   Model: {model}")
        print(f"   Provider: {provider_name}")
        
        try:
            self.provider = create_llm(provider_name, model=model)
        except Exception as e:
            print(f"‚ùå Failed to create provider: {e}")
            sys.exit(1)
        
        # Initialize embedding manager
        try:
            self.embedding_manager = EmbeddingManager(model="all-minilm-l6-v2", backend="auto")
        except Exception as e:
            print(f"‚ö†Ô∏è  Embedding manager initialization failed: {e}")
            self.embedding_manager = None
        
        # Create memory-enhanced session
        try:
            self.session = MemorySession(
                provider=self.provider,
                system_prompt=self._create_system_prompt(),
                memory_base_path=self.memory_path,
                embedding_manager=self.embedding_manager,
                default_user_id=user_id,
                default_location=location
            )
            
            print(f"‚úÖ Memory session initialized")
            
            # Show memory stats
            self._show_memory_stats()
            
        except Exception as e:
            print(f"‚ùå Failed to initialize memory session: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)

    def _create_system_prompt(self) -> str:
        """Create system prompt for memory-enhanced conversation."""
        
        return """You are a helpful AI assistant with an advanced memory system. You can:

üß† **Memory Tools Available:**
- `remember_fact()` - Store important information, insights, or preferences
- `search_memories()` - Search your memory for relevant past information
- `reflect_on()` - Engage in deep reflection on topics to analyze patterns
- `capture_document()` - Save documents to your library for future reference
- `search_library()` - Search your document library

üéØ **How to Use Memory:**
- **Remember** important facts, user preferences, insights, or anything worth preserving
- **Search** your memory when users ask about past conversations or topics
- **Reflect** on complex topics to provide deeper, more thoughtful responses
- **Capture** documents or information that might be useful later
- **Search library** for relevant documents when answering questions

üí° **Memory Philosophy:**
Your memory system automatically captures conversation history and context. Use the memory tools strategically to enhance conversations with relevant past information and insights.

Be helpful, thoughtful, and make good use of your memory capabilities to provide personalized and contextual responses."""

    def _show_memory_stats(self):
        """Show current memory statistics."""
        
        try:
            # Count existing memories
            notes_dir = self.memory_path / "notes"
            verbatim_dir = self.memory_path / "verbatim"
            
            note_count = len(list(notes_dir.rglob("*.md"))) if notes_dir.exists() else 0
            verbatim_count = len(list(verbatim_dir.rglob("*.md"))) if verbatim_dir.exists() else 0
            
            print(f"   Existing memories: {note_count}")
            print(f"   Conversation history: {verbatim_count}")
            
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Could not load memory stats: {e}")

    def handle_command(self, user_input: str) -> bool:
        """Handle special commands. Returns True if command was processed."""
        
        if not user_input.startswith('/'):
            return False
        
        cmd = user_input[1:].strip().lower()
        
        if cmd in ['quit', 'exit', 'q']:
            print("üëã Goodbye!")
            self._cleanup()
            sys.exit(0)
        
        elif cmd == 'help':
            self._show_help()
        
        elif cmd == 'stats':
            self._show_detailed_stats()
        
        elif cmd == 'history':
            self._show_conversation_history()
        
        elif cmd == 'clear':
            self.session.clear_history(keep_system=True)
            print("üßπ Conversation history cleared (memory preserved)")
        
        elif cmd == 'memory':
            self._show_memory_overview()
        
        elif cmd == 'tools':
            self._show_available_tools()
        
        elif cmd.startswith('save'):
            # Parse /save <file> [--summary] [--assessment] [--facts] command
            parts = cmd.split()
            if len(parts) < 2:
                print("‚ùì Usage: /save <filename> [--summary] [--assessment] [--facts]")
                print("   Example: /save my_conversation.json")
                print("   Example: /save analyzed_session --summary --assessment --facts")
            else:
                filename = parts[1]
                options = {
                    'summary': '--summary' in parts,
                    'assessment': '--assessment' in parts,
                    'facts': '--facts' in parts
                }
                self._handle_save(filename, **options)
        
        elif cmd.startswith('load'):
            # Parse /load <file> command
            parts = cmd.split()
            if len(parts) != 2:
                print("‚ùì Usage: /load <filename>")
                print("   Example: /load my_conversation.json")
            else:
                filename = parts[1]
                self._handle_load(filename)
        
        else:
            print(f"‚ùì Unknown command: /{cmd}. Type /help for available commands.")
        
        return True

    def _show_help(self):
        """Show help information."""
        
        print("\n" + "="*70)
        print("üß† AbstractMemory REPL - Memory-Enhanced AI Assistant".center(70))
        print("="*70)
        
        print("\nüìñ COMMANDS")
        print("‚îÄ" * 50)
        print("  /help                    Show this help")
        print("  /quit                    Exit the REPL")
        print("  /clear                   Clear conversation history")
        print("  /stats                   Show detailed memory statistics")
        print("  /history                 Show recent conversation")
        print("  /memory                  Show memory overview")
        print("  /tools                   Show available memory tools")
        print("  /save <file> [options]   Save session with optional analytics")
        print("  /load <file>             Load saved session")
        
        print("\nüß† MEMORY FEATURES")
        print("‚îÄ" * 50)
        print("  ‚Ä¢ Automatic conversation storage")
        print("  ‚Ä¢ Semantic memory search")
        print("  ‚Ä¢ Context reconstruction from memory")
        print("  ‚Ä¢ Document library management")
        print("  ‚Ä¢ Automatic fact extraction")
        print("  ‚Ä¢ Memory consolidation")
        
        print("\nüõ†Ô∏è AVAILABLE TOOLS")
        print("‚îÄ" * 50)
        print("  Memory Tools:")
        print("    ‚Ä¢ remember_fact() - Store important information")
        print("    ‚Ä¢ search_memories() - Search past conversations")
        print("    ‚Ä¢ reflect_on() - Deep reflection and analysis")
        print("    ‚Ä¢ capture_document() - Save documents to library")
        print("    ‚Ä¢ search_library() - Search document library")
        print("  File & System Tools:")
        print("    ‚Ä¢ list_files() - List directory contents")
        print("    ‚Ä¢ search_files() - Search inside files")
        print("    ‚Ä¢ read_file() - Read file contents")
        print("    ‚Ä¢ write_file() - Create/modify files")
        print("    ‚Ä¢ edit_file() - Edit files with patterns")
        print("    ‚Ä¢ execute_command() - Run shell commands")
        
        print("\nüí° TIPS")
        print("‚îÄ" * 50)
        print("  ‚Ä¢ Ask about past conversations - I remember them!")
        print("  ‚Ä¢ I can reflect on topics to provide deeper insights")
        print("  ‚Ä¢ Share documents or information for me to remember")
        print("  ‚Ä¢ My memory grows and improves with each interaction")
        
        print("="*70 + "\n")

    def _show_detailed_stats(self):
        """Show detailed memory and session statistics."""
        
        print("\nüìä Memory Statistics")
        print("=" * 50)
        
        try:
            # Memory file counts
            notes_dir = self.memory_path / "notes"
            verbatim_dir = self.memory_path / "verbatim"
            library_dir = self.memory_path / "library"
            
            note_files = list(notes_dir.rglob("*.md")) if notes_dir.exists() else []
            verbatim_files = list(verbatim_dir.rglob("*.md")) if verbatim_dir.exists() else []
            library_files = list(library_dir.rglob("*.md")) if library_dir.exists() else []
            
            print(f"üìù Notes: {len(note_files)}")
            print(f"üí¨ Conversations: {len(verbatim_files)}")
            print(f"üìö Library Documents: {len(library_files)}")
            
            # Session stats
            messages = self.session.get_messages()
            print(f"üó®Ô∏è  Current Session Messages: {len(messages)}")
            print(f"üî¢ Estimated Tokens: ~{self.session.get_token_estimate():,}")
            
            # Tool stats
            print(f"üõ†Ô∏è  Available Tools: {len(self.session.tools)}")
            
            # Memory path info
            print(f"üìÅ Memory Path: {self.memory_path}")
            print(f"üë§ User ID: {self.user_id}")
            print(f"üìç Location: {self.location}")
            
        except Exception as e:
            print(f"‚ùå Error getting stats: {e}")
        
        print("=" * 50)

    def _show_conversation_history(self):
        """Show recent conversation history."""
        
        print("\nüí¨ Recent Conversation")
        print("=" * 50)
        
        try:
            messages = self.session.get_messages()
            
            # Show last 10 messages (excluding system)
            recent_messages = [m for m in messages if m.role != 'system'][-10:]
            
            if not recent_messages:
                print("No conversation history yet.")
            else:
                for msg in recent_messages:
                    if msg.role == 'user':
                        print(f"üë§ You: {msg.content}")
                    elif msg.role == 'assistant':
                        print(f"ü§ñ Assistant: {msg.content}")
                    elif msg.role == 'tool':
                        print(f"üõ†Ô∏è  Tool: {msg.content[:100]}...")
                    print()
            
        except Exception as e:
            print(f"‚ùå Error getting history: {e}")
        
        print("=" * 50)

    def _show_memory_overview(self):
        """Show memory system overview."""
        
        print("\nüß† Memory System Overview")
        print("=" * 50)
        
        try:
            # Check memory components
            components = [
                ("Working Memory", hasattr(self.session, 'working_memory')),
                ("Episodic Memory", hasattr(self.session, 'episodic_memory')),
                ("Semantic Memory", hasattr(self.session, 'semantic_memory')),
                ("Library Memory", hasattr(self.session, 'library')),
                ("LanceDB Storage", self.session.lancedb_storage is not None),
                ("Fact Extractor", self.session.fact_extractor is not None),
                ("Consolidation Scheduler", hasattr(self.session, 'consolidation_scheduler'))
            ]
            
            for component, available in components:
                status = "‚úÖ" if available else "‚ùå"
                print(f"{status} {component}")
            
            # Memory directories
            print(f"\nüìÅ Memory Structure:")
            for subdir in ['notes', 'verbatim', 'library', 'core', 'working', 'episodic', 'semantic']:
                path = self.memory_path / subdir
                exists = "‚úÖ" if path.exists() else "üìÅ"
                print(f"   {exists} {subdir}/")
            
        except Exception as e:
            print(f"‚ùå Error getting memory overview: {e}")
        
        print("=" * 50)

    def _show_available_tools(self):
        """Show available memory tools."""
        
        print("\nüõ†Ô∏è  Available Memory Tools")
        print("=" * 50)
        
        try:
            if hasattr(self.session, 'tools') and self.session.tools:
                for tool in self.session.tools:
                    print(f"üìå {tool.name}")
                    if hasattr(tool, 'description'):
                        print(f"   {tool.description}")
                    print()
            else:
                print("No tools available")
        
        except Exception as e:
            print(f"‚ùå Error getting tools: {e}")
        
        print("=" * 50)

    def _handle_save(self, filename: str, summary: bool = False, assessment: bool = False, facts: bool = False):
        """Handle /save <file> command - save current session to file with optional analytics"""
        try:
            # Ensure .json extension for consistency
            if not filename.endswith('.json'):
                filename = f"{filename}.json"
            
            print(f"üíæ Saving session to {filename}...")
            
            # Get session info before saving
            messages = self.session.get_messages()
            tokens = self.session.get_token_estimate()
            
            # Generate optional analytics if requested
            analytics_generated = []
            
            if summary:
                print("   üîÑ Generating summary...")
                try:
                    self.session.generate_summary(focus="key discussion points")
                    analytics_generated.append("summary")
                    print("   ‚úÖ Summary generated")
                except Exception as e:
                    print(f"   ‚ö†Ô∏è  Summary generation failed: {e}")
            
            if assessment:
                print("   üîÑ Generating assessment...")
                try:
                    self.session.generate_assessment()
                    analytics_generated.append("assessment")
                    print("   ‚úÖ Assessment generated")
                except Exception as e:
                    print(f"   ‚ö†Ô∏è  Assessment generation failed: {e}")
            
            if facts:
                print("   üîÑ Extracting facts...")
                try:
                    self.session.extract_facts()
                    analytics_generated.append("facts")
                    print("   ‚úÖ Facts extracted")
                except Exception as e:
                    print(f"   ‚ö†Ô∏è  Fact extraction failed: {e}")
            
            # Save using enhanced serialization
            self.session.save(filename)
            
            print(f"‚úÖ Session saved successfully!")
            print(f"   üìÅ File: {filename}")
            print(f"   üìù Messages: {len(messages)}")
            print(f"   üî¢ Tokens: ~{tokens:,}")
            print(f"   ü§ñ Provider: {self.provider_name}:{self.model_name}")
            print(f"   ‚öôÔ∏è  Settings: auto_compact={self.session.auto_compact}")
            
            if analytics_generated:
                print(f"   üìä Analytics: {', '.join(analytics_generated)}")
            
            # Note about provider restoration
            print(f"   üí° Note: Provider and tools will need to be specified when loading")
            
        except Exception as e:
            print(f"‚ùå Failed to save session: {e}")
            if self.verbose:
                import traceback
                traceback.print_exc()

    def _handle_load(self, filename: str):
        """Handle /load <file> command - load session from file"""
        try:
            # Ensure .json extension for consistency
            if not filename.endswith('.json'):
                filename = f"{filename}.json"
            
            # Check if file exists
            import os
            if not os.path.exists(filename):
                print(f"‚ùå File not found: {filename}")
                return
            
            print(f"üìÇ Loading session from {filename}...")
            
            # Store current session info for comparison
            old_messages = len(self.session.get_messages())
            old_tokens = self.session.get_token_estimate()
            
            # Load session with current provider and memory tools
            memory_tools = self.session._create_memory_tools()
            
            from abstractmemory.memory_session import MemorySession
            loaded_session = MemorySession.load(filename, provider=self.provider, tools=memory_tools)
            
            # Replace current session
            self.session = loaded_session
            
            # Get new session info
            new_messages = len(self.session.get_messages())
            new_tokens = self.session.get_token_estimate()
            
            print(f"‚úÖ Session loaded successfully!")
            print(f"   üìÅ File: {filename}")
            print(f"   üìù Messages: {old_messages} ‚Üí {new_messages}")
            print(f"   üî¢ Tokens: ~{old_tokens:,} ‚Üí ~{new_tokens:,}")
            print(f"   ü§ñ Provider: {self.provider_name}:{self.model_name} (current)")
            print(f"   ‚öôÔ∏è  Settings: auto_compact={self.session.auto_compact}")
            
            # Show session structure
            messages = self.session.get_messages()
            conversation_messages = [msg for msg in messages if msg.role != 'system']
            interactions = len(conversation_messages) // 2
            
            has_summary = any(msg.role == 'system' and '[CONVERSATION HISTORY]' in msg.content for msg in messages)
            if has_summary:
                print(f"   üìö History: Compacted conversation with {interactions} recent interactions")
            else:
                print(f"   üí¨ History: Full conversation with {interactions} interactions")
            
        except Exception as e:
            print(f"‚ùå Failed to load session: {e}")
            if self.verbose:
                import traceback
                traceback.print_exc()

    def _cleanup(self):
        """Cleanup before exit."""
        
        try:
            # Save embedding cache if available
            if hasattr(self.session, 'embedding_manager') and self.session.embedding_manager:
                print("   üíæ Saved embedding cache")
        except Exception:
            pass

    def run(self):
        """Run the interactive REPL."""
        
        print("\n" + "="*70)
        print("üß† AbstractMemory REPL".center(70))
        print("="*70)
        print("Type /help for commands, or just chat naturally.")
        print("I have memory tools and will remember our conversations!")
        print("="*70)
        
        try:
            while True:
                try:
                    user_input = input(f"\nüë§ {self.user_id}> ").strip()
                    
                    if not user_input:
                        continue
                    
                    # Handle commands
                    if self.handle_command(user_input):
                        continue
                    
                    # Generate response using memory-enhanced session
                    start_time = time.time()
                    
                    if not self.verbose:
                        print(f"\nü§ñ Thinking...")
                    
                    # AbstractCore handles everything - tools, conversation, etc.
                    response = self.session.generate(
                        prompt=user_input,
                        user_id=self.user_id,
                        location=self.location
                    )
                    
                    elapsed = time.time() - start_time
                    
                    if not self.verbose:
                        print(f"   ‚è±Ô∏è  Completed in {elapsed:.1f}s")
                    
                    # Display response
                    response_content = response.content if hasattr(response, 'content') else str(response)
                    print(f"\nü§ñ Assistant: {response_content}")
                    
                except KeyboardInterrupt:
                    print("\n\nüëã Use /quit to exit or continue chatting.")
                    continue
                    
                except EOFError:
                    print("\nüëã Goodbye!")
                    break
                    
                except Exception as e:
                    print(f"\n‚ùå Error: {e}")
                    if self.verbose:
                        import traceback
                        traceback.print_exc()
        
        except Exception as e:
            print(f"‚ùå Fatal error: {e}")
        
        finally:
            self._cleanup()


def main():
    """Main entry point."""
    
    parser = argparse.ArgumentParser(
        description="AbstractMemory REPL - Memory-Enhanced AI Assistant",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python repl_clean.py
  python repl_clean.py --memory-path my_memory --user-id alice
  python repl_clean.py --provider lmstudio --model qwen/qwen3-coder-30b
  python repl_clean.py --provider ollama --model qwen3-coder:30b --verbose

Features:
  ‚Ä¢ Automatic conversation storage and indexing
  ‚Ä¢ Semantic memory search and retrieval
  ‚Ä¢ Context reconstruction from memory layers
  ‚Ä¢ Memory tools for LLM agency (remember, search, reflect)
  ‚Ä¢ Document library management
  ‚Ä¢ Automatic fact extraction and consolidation

Available Tools:
  The AI can use these tools automatically during conversation:
  
  Memory Tools:
  ‚Ä¢ remember_fact() - Store important information
  ‚Ä¢ search_memories() - Search past conversations and facts
  ‚Ä¢ reflect_on() - Deep reflection and analysis
  ‚Ä¢ capture_document() - Save documents to library
  ‚Ä¢ search_library() - Search document library
  
  File & System Tools (from AbstractCore):
  ‚Ä¢ list_files() - List directory contents with patterns
  ‚Ä¢ search_files() - Search text inside files (regex support)
  ‚Ä¢ read_file() - Read file contents with line ranges
  ‚Ä¢ write_file() - Create/modify files with error handling
  ‚Ä¢ edit_file() - Edit files using pattern matching
  ‚Ä¢ execute_command() - Run shell commands safely
        """
    )
    
    # Core arguments
    parser.add_argument('--memory-path', default='repl_memory',
                       help='Path to memory storage (default: repl_memory)')
    parser.add_argument('--user-id', default='user',
                       help='User identifier (default: user)')
    parser.add_argument('--provider', default='ollama',
                       choices=['ollama', 'lmstudio', 'openai', 'anthropic'],
                       help='LLM provider to use (default: ollama)')
    parser.add_argument('--model', default='qwen3-coder:30b',
                       help='Model to use (default: qwen3-coder:30b)')
    parser.add_argument('--location', default='terminal',
                       help='Physical/virtual location (default: terminal)')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Enable verbose logging')
    
    args = parser.parse_args()
    
    # Create and run REPL
    repl = AbstractMemoryREPL(
        provider_name=args.provider,
        model=args.model,
        memory_path=args.memory_path,
        user_id=args.user_id,
        location=args.location,
        verbose=args.verbose
    )
    
    repl.run()


if __name__ == "__main__":
    main()
